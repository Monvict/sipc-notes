## Example

### 阶乘的表示方式：
```scheme
; 递归表示方法
(define (fac n)                                                                                                                                                                                           
  (if (= 1 n)                                                                                                                                                                                             
      1                                                                                                                                                                                                   
    (* n (fac (- n 1)))))                                                                                                                                                                                 
                                                                                                                                                                                                          
                                                                                                                                                                                                          
; 迭代表示法
(define (fac-p n)                                                                                                                                                                                         
  (define (fac-p-iter product count)                                                                                                                                                                      
    (if (> count n)                                                                                                                                                                                       
        product                                                                                                                                                                                           
      (fac-p-iter (* product count) (+ 1 count))))                                                                                                                                                        
  (fac-p-iter 1 1))   
```


### 斐波那契数列：
```scheme
; 递归表示方法
(define (fib n)                                                                                                                                                                                           
  (cond ((= n 0) 0)                                                                                                                                                                                       
        ((= n 1) 1)                                                                                                                                                                                       
        (else (+ (fib (- n 1)) (fib (- n 2))))))                                                                                                                                                          
                                                                                                                                                                                                          
                                                                                                                                                                                                          
                                                                                                                                                                                                          
; 迭代表示方法
(define (fib2 n)                                                                                                                                                                                          
  (fib-iter 1 0 n))                                                                                                                                                                                       
(define (fib-iter a b count)                                                                                                                                                                              
  (if (= count 0)                                                                                                                                                                                         
      b                                                                                                                                                                                                   
    (fib-iter (+ a b) a (- count 1))))   
```


### 换零钱问题 - Tree Recusion
问题：要用硬币兑换1美元，硬币总类有：50分(half-doller)、25分(quater)、10分(dimes)、5分(nickle)、1分(penny)；用上全部的5种硬币，有多少种方式进行兑换？

分析：
总的兑换方式总数等于：
1.  完全不使用50分的兑换总数
2.  使用50分的兑换总数
3.  数学表达式：f(m, n) = f(m, n-1) + f(m-coins(n), n)
```lisp
ways{ 90, 5 } = ways{ 90, 5 - 1 }      ;   完全不用50分
                 +                       ; OR
                 ways{ 90 - 50,  5 }    ;   用50分
```
 ways{ 90, 5 - 1 } ： 完全不用50分的硬币， 那么就是100分，用剩余4种硬币兑换总和
 ways{ 90 - 50,  5 }：用50分的硬币，那么就用掉1个50分硬币，还剩余（90-50）分，再在剩余的5种硬币种凑出剩余40分的总兑换方式
 
```scheme
; coin-count：使用硬币的数量
; first-denomination: 排位第一的货币的面值
; 假设货币的面值有：50(half-doller)、25(quater)、10(dimes)、5(nickle)、1(penny)
; 安装从到大到小的排序
; 当coin-count=1（只用1种硬币），那么first-denomination=1分
; 当coin-count=2（用2种硬币），那么first-denomination=5分
; 以此类推... ...
(define (first-denomination coin-count)                                                                                                                                                                   
  (cond ((= coin-count 1) 1)                                                                                                                                                                              
        ((= coin-count 2) 5)                                                                                                                                                                              
        ((= coin-count 3) 10)                                                                                                                                                                             
        ((= coin-count 4) 25)                                                                                                                                                                             
        ((= coin-count 5) 50)))                                                                                                                                                                           
                                                                                                                                                                                                          

; amount：兑换金额
; count: 使用的硬币数量
; Base Case
;  - amount=0 返回1， 表示只有1种方法兑换金额为0的情况（即：不用任何硬币）
;  - amount<0 返回0， 表示这是不存在的兑换方式
;  - count=0  返回0， 意思是我们不用任何一种硬币而要进行兑换，这也不存在的兑换方式
(define (cc amount count)                                                                                                                                                                                 
  (cond ((= amount 0) 1)                                                                                                                                                                                  
        ((or (< amount 0) (= count 0)) 0)                                                                                                                                                                 
        (else (+ (cc amount (- count 1))                                                                                                                                                                  
                 (cc (- amount (first-denomination count)) count)))))                                                                                                                                     
                                                                                                                                                                                                          
(define (count-change amount)                                                                                                                                                                             
  (cc amount 5))   
```

### 换零钱问题-Iterative

```cpp
  1 #include <iostream>                                                                                                                                                                                   
  2 #include <vector>                                                                                                                                                                                     
  3 using namespace std;                                                                                                                                                                                  
  4                                                                                                                                                                                                       
  5 int count_change(const vector<int> &coins, int mount) {                                                                                                                                               
  6   // 这里设计的非常巧妙                                                                                                                                                                               
  7   // counts 用来存储1-100元，每种金额对应的换零钱方法                                                                                                                                                 
  8   vector<int> counts(mount+1, 0);                                                                                                                                                                     
  9   // 初始化counts[0]=1, 表示金额为0时，有1中方法兑换（即不用任何硬币,就可以兑换金额为0）                                                                                                                                
 10   // 其它值都为0，表示不用任何硬币，无法对方金额超过0的钱                                                                                                                                                 
 11   counts[0] = 1;                                                                                                                                                                                      
 12                                                                                                                                                                                                       
 13   for (auto &coin : coins) {                                                                                                                                                                          
 14     for (int i = coin; i <= mount; ++i) {                                                                                                                                                             
 15       // 可以用Tree-recursion的数学公式进行理解：f(m, n) = f(m, n-1) + f(m-coins[i], n)                                                                                                               
 16       // =号左侧的count[i] 相当于 f(m, n)---> 金额为m时，换取总次数                                                                                                                                   
 17       // =号右侧的count[i] 相当于 f(m, n-1) ---> 金额为m时，没用当前硬币的兑换次数                                                                                                                    
 18       // counts[i-coin] 相当于 f(m-coins[i], n) ---> 金额为m-coins[i]时，用了当前硬币的兑换次数                                                                                                       
 19       counts[i] = counts[i] + counts[i-coin];                                                                                                                                                         
 20     }                                                                                                                                                                                                 
 21   }                                                                                                                                                                                                   
 22                                                                                                                                                                                                       
 23   return counts[mount];                                                                                                                                                                               
 24 }                                                                                                                                                                                                     
 25                                                                                                                                                                                                       
 26 int main() {                                                                                                                                                                                          
 27   vector<int> coins = {1, 5, 10, 25, 50};                                                                                                                                                             
 28   auto c = count_change(coins, 100);                                                                                                                                                                  
 29   cout << c << endl;                                                                                                                                                                                  
 30   return 0;                                                                                                                                                                                           
 31 }   
```

### 素数
**O(根号n)的迭代算法**
```scheme
(define (prime? n)                                                                                                                                                                                        
  (= (smalest-divisor n) n))                                                                                                                                                                              
                                                                                                                                                                                                          
; 从2开始进行测试
(define (smalest-divisor n)                                                                                                                                                                               
  (find-divisor n 2))                                                                                                                                                                                     
                                                                                                                                                                                                          
; 从1-根号n的数字进行测试
(define (find-divisor n test-divisor)                                                                                                                                                                     
  (cond ((> (sqr test-divisor) n) n)               ; 到根号n都找不到能整除的数                                                                                                                                                       
        ((divide? n test-divisor) test-divisor)    ; 能整除返回                                                                                                                                                       
        (else (find-divisor n (+ test-divisor 1)))))                                                                                                                                                      
                                                                                                                                                                                                          
(define (sqr x)                                                                                                                                                                                           
  (* x x))                                                                                                                                                                                                
                                                                                                                                                                                                          
(define (divide? m n)                                                                                                                                                                                     
  (= (remainder m n) 0))   
```

**O(logn)的算法**
根据费尔马测试：
> If n is a prime number and a
> is any positive integer less than n, then a raised to the nth
   power is congruent to a modulo n.
   a^n mod n = a 

```scheme
(define (expmod base exp m)                                                                                                                                                                               
  (cond ((= exp 0) 1)                                                                                                                                                                                     
        ((even? exp)                                                                                                                                                                                      
         (remainder                                                                                                                                                                                       
          (sqr (expmod base (/ exp 2) m))                                                                                                                                                                 
          m))                                                                                                                                                                                             
        (else                                                                                                                                                                                             
         (remainder                                                                                                                                                                                       
          (* base (expmod base (- exp 1) m))                                                                                                                                                              
          m))))                                                                                                                                                                                           
                                                                                                                                                                                                          
(define (fermat-test n)                                                                                                                                                                                   
  (define (try-it a)                                                                                                                                                                                      
    (= (expmod a n n) a))                                                                                                                                                                                 
  (try-it (+ 1 (random (- n 1)))))                                                                                                                                                                        
                                                                                                                                                                                                          
                                                                                                                                                                                                          
(define (fast-prime? n times)                                                                                                                                                                             
  (cond ((= times 0) #t)                                                                                                                                                                                  
        ((fermat-test n) (fast-prime? n (- times 1)))                                                                                                                                                     
        (else #f)))
```


### 求和
```scheme
(define (sum-int a b)                                                                                                                                                                                     
  (cond ((> a b) 0)                                                                                                                                                                                       
        (else (+ a (sum-int (+ a 1) b)))))                                                                                                                                                                
                                                                                                                                                                                                          
(define (sum-cube a b)                                                                                                                                                                                    
  (cond ((> a b) 0)                                                                                                                                                                                       
        (else (+ (cube a) (sum-cube (+ a 1) b)))))                                                                                                                                                        
                                                                                                                                                                                                          
                                                                                                                                                                                                          
(define (sum-pi a b)                                                                                                                                                                                      
  (cond ((> a b) 0)                                                                                                                                                                                       
        (else (+ (/ 1.0 (* a (+ a 2)))                                                                                                                                                                    
                 (sum-pi (+ a 4) b)))))                                                                                                                                                                   
                                                                                                                                                                                                          
(define (sum op a next b)                                                                                                                                                                                 
  (cond ((> a b) 0)                                                                                                                                                                                       
        (else (+ (op a)                                                                                                                                                                                   
                 (sum op (next a) next b)))))  

(define (inc n)                                                                                                                                                                                           
  (+ n 1))                                                                                                                                                                                                
                                                                                                                                                                                                          
(define (identity n) n)                                                                                                                                                                                   
                                                                                                                                                                                                          
(define (sum-cube-new a b)                                                                                                                                                                                
  (sum cube a inc b))                                                                                                                                                                                     
                                                                                                                                                                                                          
(define (sum-int-new a b)                                                                                                                                                                                 
  (sum identity a inc b))                                                                                                                                                                                 
                                                                                                                                                                                                          
(define (sum-pi-new a b)                                                                                                                                                                                  
  (define (pi-op x)                                                                                                                                                                                       
    (/ 1.0 (* x (+ x 2))))                                                                                                                                                                                
  (define (pi-next x)                                                                                                                                                                                     
    (+ x 4))                                                                                                                                                                                              
  (sum pi-op a pi-next b))  

(define (interal f a b dx)                                                                                                                                                                                
  (define (next x)                                                                                                                                                                                        
    (+ x dx))                                                                                                                                                                                             
  (* (sum f (+ a (/ dx 2.0)) next b) dx))  
```

## Exercise
### 1.11
```scheme
; recusion表示（if）
(define (fn n)                                                                                                                                                                                            
  (if (< n 3 ) n                                                                                                                                                                                          
    (+ (fn (- n 1))                                                                                                                                                                                       
       (* 2 (fn (- n 2)))                                                                                                                                                                                 
       (* 3 (fn (- n 3))))))                                                                                                                                                                              
                                                                                                                                                                                                          
                                                                                                                                                                                                          
; recusion表示（cond）
(define (fn n)                                                                                                                                                                                            
  (cond ((< n 3) n)                                                                                                                                                                                       
        (else (+ (fn (- n 1))                                                                                                                                                                             
                 (* 2 (fn (- n 2)))                                                                                                                                                                       
                 (* 3 (fn (- n 3)))))))  


; iterator表示
; 这里迭代类似于fib的表示方法
; 每次迭代a、b、c的值变换如下：
; a = a + 2b + 3c
; b = a
; c = a
; 此种清空下，a在每次迭代都保存了目标值，需要在迭代适当的Ｎ次后返回接口

(define (fn-iter a b c count)                                                                                                                                                                             
  (cond ((= count 0) a)                                                                                                                                                                                   
        (else (fn-iter (+ a (* 2 b) (* 3 c)) a b (- count 1)))))                                                                                                                                          
                                                                                                                                                                                                          
; count ---> 用来控制迭代次数, 因为 1 2这两种清空不参与迭代
; 所以在调用 fn-iter时 count = n - 2
; 否则count迭代次数偏多，结果就不正确
(define (fn2 n)                                                                                                                                                                                           
  (cond ((< n 2) n)                                                                                                                                                                                       
        (else (fn-iter 2 1 0 (- n 2)))))  
```

### 1.12
题目：给定帕斯卡三角的row和col，得出当前row&col对应的值。
分析：
帕斯卡三角的特点：
1. 第一个数是1
2. 两条斜边都是1
3. 中间的数=上一行两个数之和
将杨辉三角的特点翻译成数学表达式：
1. 第一个数为1  ---> row=1  then `value = 1`
2. 最左斜边为1  ---> col=1  then `value = 1`
3. 最右斜边为1  ---> col=row   then `value = 1`
4. 中间的数=上一行两个数之和 ---> f(row, col) = f(row-1, rol - 1) + f(row-1, col)
```scheme
(define (pasca row col)                                                                                                                                                                                   
  (cond ((= row 1) 1)                                                                                                                                                                                     
        ((= col 1) 1)                                                                                                                                                                                     
        ((= row col) 1)                                                                                                                                                                                   
        (else (+ (pasca (- row 1) (- col 1))                                                                                                                                                              
                 (pasca (- row 1) col)))))                                                                                                                                                                
                                                
```

### 1.16
题目：b＾n的表示方法
分析：
下面的程序分为4部分：
**1. 时间复杂的为O(n)表示方式（tree recursion）**
根据b^n 可以拆分为：
- b^n = b * b^n-1
- b^0 = 1

**2 时间复杂的为O(n)表示方式（iterative recursion）**
根据b^n 可以拆分为：
- b^n = b * b^n-1
- b^0 = 1
再多加一个记录结果的product参数

**3. 时间复杂度为O(log(n))的表示方式（tree recursion）**
根据n的奇偶性，b^n可以分为以下2种情况：
- b^n = (b＾n/2)^2   -- n为偶数
- b^n = b * b^n-1     -- n为奇数
当n为偶数时，经过几次对数级别的递减后，会最终回归到n=1的情况
当n为奇数时，在n-1后变为偶数，重复上诉n为偶数的步骤

**4. 时间复杂度为O(log(n))的表示方式（iterative recursion）**
根据n的奇偶性，b^n可以分为以下2种情况：
- b^n = (b＾2)^(n/2)   -- n为偶数
- b^n = b * b^n-1     -- n为奇数
当n为偶数时，经过几次对数级别的递减后，会最终回归到n=1的情况
当n为奇数时，在n-1后变为偶数，重复上诉n为偶数的步骤

再多加一个记录结果的product参数，product = b * product


```scheme
;1. 时间复杂的为O(n)表示方式（tree recursion）
(define (expt b n)                                                                                                                                                                                        
  (cond ((= n 0) 1)                                                                                                                                                                                       
        (else (* b (expt b (- n 1))))))                                                                                                                                                                   
                                                                                                                                                                                 
;2. 时间复杂的为O(n)表示方式（iterative recursion）
(define (expt-better b n)                                                                                                                                                                                 
  (expt-b b n 1))                                                                                                                                                                                         
                                                                                                                                                                                                          
(define (expt-b b n prod)                                                                                                                                                                                 
  (cond ((= n 0) prod)                                                                                                                                                                                    
        (else (expt-b b (- n 1) (* b prod))))) 
        

; 3. 时间复杂度为O(log(n))的表示方式（tree recursion）
(define (fast-expt b n)                                                                                                                                                                                   
  (cond ((= n 0) 1)                                                                                                                                                                                       
        ((even? n) (sqr (fast-expt b (/ n 2))))                                                                                                                                                           
        (else (* b (fast-expt b (- n 1))))))  

(define (even? n)                                                                                                                                                                                         
  (= (remainder n 2) 0))                                                                                                                                                                                  
                                                                                                                                                                                                          
(define (sqr x)                                                                                                                                                                                           
  (* x x))  
                                                                                                                                                                                                          
; 4. 时间复杂度为O(log(n))的表示方式（iterative recursion）
(define (perfect-expt b n)                                                                                                                                                                                    
  (iter-expt b n 1)) 

(define (iter-expt b n a)                                                                                                                                                                                 
  (cond ((= n 0) a)                                                                                                                                                                                       
        ((even? n) (iter-expt (sqr b) (/ n 2) a))                                                                                                                                                         
        (else (iter-expt b (- n 1) (* a b)))))    
```

### 1.17
题目：a * b的表示方法
分析：
下面的程序分为3部分：
**1. 时间复杂的为O(n)表示方式（tree recursion）**
根据a * b 可以拆分为：
- a * b = a + a * (b - 1)
- b = 0时，返回0

**2. 时间复杂度为O(log(n))的表示方式（tree recursion）**
引入2个辅助procedure：double 和 half
再根据n的奇偶性，a * b可以分为以下2种情况：
- a * b= double (a * (half b))   -- n为偶数
- a * b = a + a * (b - 1) -- n为奇数
- b = 0时，返回0
当n为偶数时，经过几次对数级别的递减后，会最终回归到n=1的情况
当n为奇数时，在n-1后变为偶数，重复上诉n为偶数的步骤

```scheme
(define (mult a b)                                                                                                                                                                                        
  (cond ((= b 0) 0)                                                                                                                                                                                       
        ((+ a (mult a (- b 1))))))                                                                                                                                                                        
                                                                                                                                                                                                          
(define (double x)                                                                                                                                                                                        
  (* x 2))                                                                                                                                                                                                
                                                                                                                                                                                                          
(define (half x)                                                                                                                                                                                          
  (/ x 2))

(define (even? n)                                                                                                                                                                                         
  (= (remainder n 2) 0))  
                                                                                                                                                                                                          
(define (fast-mult a b)                                                                                                                                                                                   
  (cond ((= b 0) 0)                                                                                                                                                                                       
        ((even? b) (double (fast-mult a (half b))))                                                                                                                                                       
        (else (+ a (fast-mult a (- b 1)))))) 
```

### 1.18
**3. 时间复杂度为O(log(n))的表示方式（iterative recursion）**
引入2个辅助procedure：double 和 half
根据n的奇偶性，b^n可以分为以下2种情况：
-  a * b= double(a) * half(b)  -- n为偶数
- a * b = a + a * (b - 1) -- n为奇数
-  b = 0时，返回 product
当n为偶数时，经过几次对数级别的递减后，会最终回归到n=1的情况
当n为基数时，在n-1后变为偶数，重复上诉n为偶数的步骤

再多加一个记录结果的product参数，product = product + a
```scheme
(define (iter-mult a b product)                                                                                                                                                                           
  (cond ((= b 0) product)                                                                                                                                                                                 
        ((even? b) (iter-mult (double a) (half b) product))                                                                                                                                               
        (else (iter-mult a (- b 1) (+ a product)))))                                                                                                                                                      
                                                                                                                                                                                                          
(define (perfect-mult a b)                                                                                                                                                                                
  (iter-mult a b 0))    
```


### 1.22
```scheme
; 获取下一个奇数
(define (next-odd n)                                                                                                                                                                                      
  (cond ((even? n) (+ n 1))                                                                                                                                                                               
        (else (+ n 2))))                                                                                                                                                                                  
                                                                                                                                                                                                          
; 获取联系N个质数
(define (contine-prime start n)                                                                                                                                                                           
  (cond ((= n 0) (display "are primes"))                                                                                                                                                                  
        ((prime? start)                                                                                                                                                                                   
         (display start)                                                                                                                                                                                  
         (newline)                                                                                                                                                                                        
         (contine-prime (next-odd start) (- n 1)))                                                                                                                                                        
        (else (contine-prime (next-odd start) n))))                                                                                                                                                       
                                                                                                                                                                                                          
; 统计获取N个质数使用时间
(define (search-for-prime n)                                                                                                                                                                              
  (let ((start-time (real-time-clock)))                                                                                                                                                                   
    (contine-prime n 3)                                                                                                                                                                                   
    (- (real-time-clock) start-time))) 

```

### 1.23
```scheme
(define (next-divisor n)                                                                                                                                                                                  
  (cond ((= n 2) 3)                                                                                                                                                                                       
        (else (+ n 2))))  
```


### 1.27
```scheme
(define (full-fermat-prime n)                                                                                                                                                                             
  (define (try-it a)                                                                                                                                                                                      
    (cond ((= a n) #t)                                                                                                                                                                                    
          ((= (expmod a n n) a) (try-it (+ a 1)))                                                                                                                                                         
          (else #f)))                                                                                                                                                                                     
  (try-it 1)) 
```

